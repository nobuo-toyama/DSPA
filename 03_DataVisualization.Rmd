---
title: "03_DataVisualization"
author: "nobuo"
date: "2021/4/19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this chapter, we use a broad range of simulations and hands-on activities to highlight some of the basic data visualization techniques using R. A brief discussion of alternative visualization methods is followed by demonstrations of histograms, density, pie, jitter, bar, line and scatter plots, as well as strategies for displaying trees and graphs and 3D surface plots. Many of these are also used throughout the textbook in the context of addressing the graphical needs of specific case-studies.     	

It is practically impossible to cover all options of every different visualization routine. Readers are encouraged to experiment with each visualization type, change input data and parameters, explore the function documentation using R-help (e.g., `?plot`), and search for new R visualization packages and new functionality, which are continuously being developed.	

# Questions	
* What exploratory visualization techniques are available to visually interrogate my specific data? 	
* How to examine paired associations and correlations in a multivariate dataset?

# Classification of visualization methods

Scientific data-driven or simulation-driven visualization methods are hard to classify. The following list of criteria can be used for classification:	

* **Data Type**: structured/unstructured, small/large, complete/incomplete, time/space, ASCII/binary, Euclidean/non-Euclidean, etc.	
* **Task type**: Task  type  is  one  of  the  aspects  considered  in classification  of  visualization  techniques,  which provides means of interaction between the researcher, the data and the display software/platform	
* **Scalability**:  Visualization techniques are subject to some limitations, such as the amount of data that a particular technique can exhibit  	
* **Dimensionality**: Visualization techniques can also be classified according to the number of attributes	
* **Positioning and Attributes**: the distribution of attributes on the chart may affect the interpretation of the display representation, e.g., correlation analysis, where the relative distance among the plotted attributes is relevant for observation	
* **Investigative Need**: the specific scientific question or exploratory interest may also determine the type of visualization:	
   +Examining the composition of the data	
   +Exploring the distribution of the data	
   +Contrasting or comparing several data elements, relations, association	
   +Unsupervised exploratory data mining
   
Also, we have the following table for common data visualization methods according to task types:	

We chose to introduce common data visualization methods according to this classification criterion, albeit this is not a unique or even broadly agreed upon ontological characterization of exploratory data visualization. 	

# Composition

In this section, we will see composition plots for different types of variables and data structures.	

## Histograms and density plots

One of the first few graphs we learned in high school would be Histogram. In R, the command `hist()` is applied to a vector of values and used for plotting histograms. The famous 19-th century statistician [Karl Pearson](https://en.wikipedia.org/wiki/Karl_Pearson) introduced histograms as graphical representations of the distribution of a sample of numeric data. The histogram plot uses the data to infer and display the probability distribution of the underlying population that the data is sampled from. Histograms are constructed by selecting a certain number of bins covering the range of values of the observed process. Typically, the number of bins for a data array of size $N$ should be equal to $\sqrt{N}$. These bins form a partition (disjoint and covering sets) of the range. Finally, we compute the relative frequency representing the number of observations that fall within each bin interval. The histogram just plots a piece-wise step-function defined over the union of the bin interfaces whose height equals the observed relative frequencies.	

```{r}
set.seed(1)	
x <- rnorm(1000)	
hist(x, freq=F, breaks = 10)	
lines(density(x), lwd=2, col="blue") 	
t <- seq(-3, 3, by=0.01)	
lines(t, dnorm(t,0,1), col="magenta") # add the theoretical density line	
```

Here `freq=T` shows the frequency for each *x* value and `breaks` controls for number of bars in our histogram.	

The shape of last histogram we draw is very close to a Normal distribution (because we sampled from this distribution by `rnorm`). We can add a density line to the histogram.	

```{r}
hist(x, freq=F, breaks = 10)	
lines(density(x), lwd=2, col="blue")
```

Here we used the option `freq=F` to make the *y* axis represent the "relative frequency", or "density". We can also use `plot(density(x))` to draw the density plot by itself.	

```{r}
plot(density(x))
```

## Pie Chart

We are all very familiar with pie charts that show us the components of a big "cake". Although pie charts provide effective simple visualization in certain situations, it may also be difficult to compare segments within a pie chart or across different pie charts. Other plots like bar chart, box or dot plots may be attractive alternatives.	

We will use the Letter Frequency Data on [SOCR website](https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData) to illustrate the use of pie charts.

```{r}
library(rvest)	
wiki_url <- read_html("https://wiki.socr.umich.edu/index.php/SOCR_LetterFrequencyData")	
html_nodes(wiki_url, "#content")	
letter<- html_table(html_nodes(wiki_url, "table")[[1]])	
summary(letter)	
```

We can try to plot the frequency for first 10 letters in English. The left hand side plot is the one without reference table and the right one has the table made by function `legend`.	

```{r}
par(mfrow=c(1, 2))	
pie(letter$English[1:10], labels=letter$Letter[1:10],
    col=rainbow(10, start=0.1, end=0.8),
    clockwise=TRUE,
    main="First 10 Letters Pie Chart")	
pie(letter$English[1:10], labels=letter$Letter[1:10],
    col=rainbow(10, start=0.1, end=0.8),
    clockwise=TRUE,
    main="First 10 Letters Pie Chart")	
legend("topleft",
       legend=letter$Letter[1:10],
       cex=1.3, bty="n", pch=15, pt.cex=1.8, 
       col=rainbow(10, start=0.1, end=0.8), ncol=1)	
```

The input type for `pie()` is a vector of non-negative numerical quantities. In the `pie` function we list the data that we are going to use (positive and numeric), the labels for each of them, and the colors we want to use for each sector. In the `legend` function, we put the location in the first slot and `legend` are the labels for colors. `cex`, `bty`, `pch`, and `pt.cex` are all graphic parameters that we have talked about in [Chapter 1](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/01_Foundation.html).	

More elaborate pie charts, using the Latin letter data, will be demonstrated using `ggplot` later, ([Section 7.2](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/03_DataVisualization.html#72_some_additional_ggplot_examples).	

## Heat map

Another common data visualization method is the `heat map`. Heat maps can help us visualize the individual values in a matrix intuitively. It is widely used in genetics research and financial applications.	

We will illustrate the use of heat maps, based on a [neuroimaging genetics case-study data](http://dx.doi.org/10.4306/pi.2015.12.1.125) about the association (p-values) of different brain regions of interest (ROIs) and genetic traits (SNPs) for Alzheimer's disease (AD) patients, subjects with mild cognitive impairment (MCI), and normal controls (NC). First, let's import the data into R. The data are 2D arrays where the rows represent different genetic SNPs, columns represent brain ROIs, and the cell values represent the strength of the SNP-ROI association, a probability values (smaller p-values indicate stronger neuroimaging-genetic associations).	

```{r}
AD_Data <- read.table("https://umich.instructure.com/files/330387/download?download_frd=1", header=TRUE, row.names=1,  sep=",", dec=".")	 	
MCI_Data <- read.table("https://umich.instructure.com/files/330390/download?download_frd=1", header=TRUE, row.names=1,  sep=",", dec=".")	 	 	
NC_Data <- read.table("https://umich.instructure.com/files/330391/download?download_frd=1", header=TRUE, row.names=1,  sep=",", dec=".")	 	 	
```

Then we load the R packages we need for heat maps (use `install.packages("package name")` first if you did not install them into your computer). 	

```{r}
library(graphics)	
library(grDevices)	
library(gplots)
```

Then we convert the datasets into matrices.

```{r}
AD_mat  <- as.matrix(AD_Data); class(AD_mat) <- "numeric"	
MCI_mat  <- as.matrix(MCI_Data); class(MCI_mat) <- "numeric"	
NC_mat  <- as.matrix(NC_Data); class(NC_mat) <- "numeric"	
```

We may also want to set up the row (rc) and column (cc) colors for each cohort.	

```{r}
rcAD <- rainbow(nrow(AD_mat),
                start = 0, end = 1.0)
ccAD <- rainbow(ncol(AD_mat),
                start = 0, end = 1.0)	
rcMCI <- rainbow(nrow(MCI_mat),
                start = 0, end=1.0)
ccMCI <- rainbow(ncol(MCI_mat),
                start=0, end=1.0)	
rcNC <- rainbow(nrow(NC_mat),
                start = 0, end = 1.0)
ccNC <- rainbow(ncol(NC_mat),
                start = 0, end = 1.0)	
```

Finally, we got to the point where we can plot heat maps. As we can see, the input type of `heatmap()` is a numeric matrix.	

```{r}
hvAD <- heatmap(AD_mat,
                col = cm.colors(256),
                scale = "column",
                RowSideColors = rcAD,
                ColSideColors = ccAD,
                margins = c(2, 2), main="AD Cohort")	
hvMCI <- heatmap(MCI_mat,
                 col = cm.colors(256),
                 scale = "column",
                 RowSideColors = rcMCI,
                 ColSideColors = ccMCI,
                 margins = c(2, 2), main="MCI Cohort")	
hvNC <- heatmap(NC_mat,
                col = cm.colors(256),
                scale = "column",
                RowSideColors = rcNC,
                ColSideColors = ccNC,
                margins = c(2, 2), main="NC Cohort")	
```

In the `heatmap()` function the first argument is for matrices we want to use. `col` is the color scheme; `scale` is a character indicating if the values should be centered and scaled in either the row direction or the column direction, or none ("row", "column", and "none"); `RowSideColors` and `ColSideColors` creates the color names for horizontal side bars.	

The differences between the AD, MCI and NC heat maps are suggestive of variations of genetic traits or alternative brain regions that may be affected in the three clinically different cohorts.	

# Comparison

Plots used for comparing different individuals, groups of subjects, or multiple units represent another set of popular exploratory visualization tools.	

## Paired Scatter Plots

Scatter plots use the 2D Cartesian plane to display a pair of variables. 2D points represent the values of the two variables corresponding to the two coordinate axes. The position of each 2D point on is determined by the Values of the first and second variables, which represent the horizontal and vertical axes. If no clear dependent variable exists, either variable can be plotted on the $X$ axis and the corresponding scatter plot will illustrate the degree of correlation (not necessarily causation) between two variables.	

Basic scatter plots can be plotted by function `plot(x, y)`.

```{r}
x<-runif(50)	
y<-runif(50)	
plot(x, y, main="Scatter Plot")	
```

`qplot()` is another way to plot fancy scatter plots. We can manage the colors and sizes of dots. The input type for `qplot()` is a data frame. In the following example, larger *x* will have larger dot sizes. We also grouped the data as 10 points per group. 	

```{r}
library(ggplot2)	
cat <- rep(c("A", "B", "C", "D", "E"), 10)  	
plot.1 <- qplot(x, y, geom="point", size=5*x, color=cat,
                main="GGplot with Relative Dot Size and Color")	
print(plot.1)	
```

Now let's draw a paired scatter plot with 3 variables. The input type for `pairs()` function is a matrix or data frame.	

```{r}
z<-runif(50)	
pairs(data.frame(x, y, z))
```

We can see that variable names are on the diagonal of this scatter plot matrix. Each plot uses the column variable as its X-axis and row variable as its Y-axis.	

Let's see a real word data example. First, we can import the Mental Health Services Survey Data into R, which is on the [class website](https://umich.instructure.com/courses/38100/files/folder/Case_Studies).	

```{r}
data1 <- read.table('https://umich.instructure.com/files/399128/download?download_frd=1', header=T)		
head(data1)	
attach(data1)	
```

We can see from `head()` that there are a lot of *NA*'s in the dataset. `pairs` automatically deal with this problem.	

```{r}
plot(data1[, 9], data1[, 10], pch=20, col="red", main="qual vs supp")	
pairs(data1[, 5:10])
```

First plot is a member of the second scatter matrix. We can see `Focus` and `PostTraum` has no relationship in that `Focus` can equal to 3 or 1 in either `PostTraum` values(0 or 1). On the other hand, larger `supp` tends to have larger `qual` values.	

To see this trend we can make a plot using `qplot` function. This allow us to add a smooth line for possible trend.	

```{r}
plot.2 <- qplot(qual, supp, data = data1, geom = c("point", "smooth"))	
print(plot.2)	
```

You can also use the [human height and weight dataset](http://wiki.stat.ucla.edu/socr/index.php/SOCR_Data_Dinov_020108_HeightsWeights) or the [knee pain dataset](https://wiki.socr.umich.edu/index.php/SOCR_Data_KneePainData_041409) to illustrate some interesting scatter plots. 	

## Jitter plot

Jitter plot can help us deal with the overplot issue when we have many points in the data. The function we will be using is still in package `ggplot2` called `position_jitter()`.	

Still we use the earthquake data for example. We will compare the differences with and without `position_jitter()` function.	

```{r}
library("xml2")
library("rvest") 	
wiki_url <- read_html("https://wiki.socr.umich.edu/index.php/SOCR_Data_Dinov_021708_Earthquakes")	
html_nodes(wiki_url, "#content")	
earthquake <- html_table(html_nodes(wiki_url, "table")[[2]])	
	
plot6.1 <- ggplot(earthquake,
                aes(Depth, Latitude, group=Magt, color=Magt)) +
  geom_point()	
plot6.2 <- ggplot(earthquake,
                  aes(Depth, Latitude, group=Magt, color=Magt)) +
  geom_point(position = position_jitter(w = 0.3, h = 0.3), alpha=0.5)	
print(plot6.1)	
print(plot6.2)	
```

Note that with option `alpha=0.5` the "crowded" places are darker than the places with only one data point. 	

Sometimes, we need to add text to these points, i.e., add label in `aes` or add `geom_text`. It looks messy.	

```{r}
ggplot(earthquake,
       aes(Depth, Latitude, group=Magt, color=Magt,label=rownames(earthquake)))+	
  geom_point(position = position_jitter(w = 0.3, h = 0.3), alpha=0.5)+geom_text()	
```

Let's try to fix the overlap of points and labels. We need to add `check_overlap` in `geom_text` and adjust the positions of the text labels with respect to the points.	

```{r}
ggplot(earthquake,
       aes(Depth, Latitude, group=Magt, color=Magt,label=rownames(earthquake))) +
  geom_point(position = position_jitter(w = 0.3, h = 0.3), alpha=0.5) +	
  geom_text(check_overlap = T,vjust = 0, nudge_y = 0.5, size = 2,angle = 45)

# Or you can simply use the text to deote the positions of points.	
ggplot(earthquake,
       aes(Depth, Latitude, group=Magt, color=Magt,label=rownames(earthquake))) +	
  geom_text(check_overlap = T,vjust = 0, nudge_y = 0, size = 3,angle = 45)	
# Warning: check_overlap will not show those overlaped points. Thus, if you need an analysis at the level of every instance, do not use it.	
```

## Bar Plots

Bar plots, or bar charts, represent group data with rectangular bars. There are many variants of bar charts for comparison among categories. Typically, either horizontal or vertical bars are used where one of the axes shows the compared categories and the other axis representing a discrete value. It's possible, and sometimes desirable, to plot bar graphs including bars clustered by groups.	

In R we have `barplot()` function explicitly designed for these plots. The input for `barplot()` is either a vector or matrix.	

```{r}
x <- matrix(runif(50), ncol=5, dimnames=list(letters[1:10], LETTERS[1:5]))	
x	
barplot(x[1:4, ], ylim=c(0, max(x[1:4, ])+0.3),
        beside=TRUE, legend.text = letters[1:4],
        args.legend = list(x = "topleft"))	
text(labels=round(as.vector(as.matrix(x[1:4, ])), 2),
     x=seq(1.5, 21, by=1) + rep(c(0, 1, 2, 3, 4), each=4),
     y=as.vector(as.matrix(x[1:4, ]))+0.1)	
```

We can see the methods that adds value labels on each bar is very hard. First, let's figure out how to get the location on x axis `x=seq(1.5, 21, by=1)+ rep(c(0, 1, 2, 3, 4), each=4)`. We know there are 20 bars. The x location for middle of the first bar is 1.5 (there is one empty space before the first bar). Middle of the last bar is 24.5. `seq(1.5, 21, by=1)` start from 1.5 and creates 20 bars that ends with `x=21`. Then we use `rep(c(0, 1, 2, 3, 4), each=4)` to add 0 to the first group, 1 to the second group and so forth. Then, we have the desired position on x-axis. Y-axis is just adding 0.1 to each bar height.	

We can add standard deviation for the 10 times the means on the bars. To do this we need to use `arrows()` function. When we have the option `angle = 90`, it turns out to be like one side of a box plot.	

```{r}
bar <- barplot(m <- rowMeans(x) * 10, ylim=c(0, 10))	
stdev <- sd(t(x[1:4, ]))	
arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)	
```

Let's look at a more complex example. We utilize the dataset [Case_04_ChildTrauma](https://umich.instructure.com/courses/38100/files/folder/Case_Studies) for illustration. This case study examines associations between post-traumatic psychopathology and service utilization by trauma-exposed children.  	

```{r}
data2 <- read.table('https://umich.instructure.com/files/399129/download?download_frd=1', header=T)		
attach(data2)	
head(data2)	
```

We have two character variables. Our goal is to draw a bar plot comparing the means of `age` and `service` among different races in this study and we want add standard deviation for each bar. The first thing to do is deleting the two character columns. Remember the input for `barplot()` is numerical vector or matrix. However, we will need race information for classification. Thus, we store it in a different dataset.

```{r}
data2.sub <- data2[, c(-5, -6)] 	
data2 <- data2[, -6]	
```

Then, we are ready to separate groups and get group means.

```{r}
data2.df <- as.data.frame(data2)	
Blacks <- data2[which(data2$race=="black"), ]	
Other <- data2[which(data2$race=="other"), ]	
Hispanic <- data2[which(data2$race=="hispanic"), ]	
White <- data2[which(data2$race=="white"), ]	
	
B <- c(mean(Blacks$age), mean(Blacks$service))	
O <- c(mean(Other$age), mean(Other$service))	
H <- c(mean(Hispanic$age), mean(Hispanic$service))	
W <- c(mean(White$age), mean(White$service))	
	
x <- cbind(B, O, H, W)	
x	
```

Until now, we had a numerical matrix for the means available for plotting. Now, we can compute a second order statistics - standard deviation, and plot it along with the means, to illustrate the amount of dispersion for each variable.	

```{r}
bar <- barplot(x, ylim=c(0, max(x)+2.0), beside=TRUE, 	
legend.text = c("age", "service") ,  args.legend = list(x = "right"))	
text(labels=round(as.vector(as.matrix(x)), 2), x=seq(1.4, 21, by=1.5), #y=as.vector(as.matrix(x[1:2, ]))+0.3)	
	y=11.5)	
	
m <- x; stdev <- sd(t(x))	
arrows(bar, m, bar, m + stdev, length=0.15, angle = 90)	
```

Here, we want the y margin to be little higher than the greatest value (`ylim=c(0, max(x)+2.0)`) because we need to leave space for value labels. Now we can easily notice that Hispanic trauma-exposed children are the youngest in terms of average age and they are less likely to utilize services like primary care, emergency room, outpatient therapy, outpatient psychiatrist, etc.	

Another way to plot bar plots is to use `ggplot()` in the ggplot package. This kind of bar plots are quite different from the one we introduced previously. It plot the counts of character variables rather than the means of numerical variables. It takes the values from a `data.frame`. Unlike `barplot()` drawing bar plots from `ggplot2` requires to remain the character variables in the original data frame.	

```{r}
library(ggplot2)	
data2 <- read.table('https://umich.instructure.com/files/399129/download?download_frd=1', header=T)		
bar1 <- ggplot(data2, aes(race, fill=race)) + geom_bar()+facet_grid(. ~ traumatype) 	
print(bar1)
```

This plot help us to compare the occurrence of different types of child-trauma among different races.	

## Trees and Graphs

In general, a [graph](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)) is an ordered pair $G = (V, E)$ of vertices ($V$). i.e., nodes or points, and a set edges ($E$), arcs or lines connecting pairs of nodes in $V$. A [tree](https://en.wikipedia.org/wiki/Tree_(graph_theory)) is a special type of acyclic graph that does not include looping paths. Visualization of graphs is critical in many biosocial and health studies and we will see examples throughout this textbook.	

In [Chapter 9](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/09_RegressionForecasting.html) and [Chapter 12](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/12_kMeans_Clustering.html) we will learn more about how to build tree models and other clustering methods, and in [Chapter 22](https://www.socr.umich.edu/people/dinov/courses/DSPA_notes/22_DeepLearning.html), we will discuss deep learning and neural networks, which have direct graphical representation.	

This section will be focused on displaying tree graphs. We will use [02_Nof1_Data.csv](https://umich.instructure.com/courses/38100/files/folder/data) for this demonstration.	

```{r}
data3<- read.table("https://umich.instructure.com/files/330385/download?download_frd=1", sep=",", header = TRUE)	
head(data3)	
```

We use `hclust` to build the hierarchical cluster model. `hclust` takes only inputs that have dissimilarity structure as produced by `dist()`. Also, we use `ave` method for agglomeration. Then we can plot our first tree graph.	

```{r}
hc<-hclust(dist(data3), method='ave') 	
par (mfrow=c(1, 1))	
plot(hc)
```

When we have no limit for maximum cluster groups, we will get the above graph, which is miserable to look at. Luckily, `cutree` will help us to set limitations to number of clusters. `cutree()` takes a `hclust` object and returns a vector of group indicators for all observations.  	

```{r}
require(graphics)	
mem <- cutree(hc, k = 10)	
	
# mem; # to print the hierarchical tree labels for each case	
# which(mem==5)  # to identify which cases belong to class/cluster 5	
# To see the number of Subjects in which cluster:	
# table(cutree(hc, k=5))	
```

Then, we can get the mean of each variable within groups by the following for loop.	

```{r}
cent <- NULL	
for(k in 1:10){	
  		cent <- rbind(cent, colMeans(data3[mem == k, , drop = FALSE]))	
}	
```

Now we can plot the new tree graph with 10 groups. With `members=table(mem)` option, the matrix is taken to be a dissimilarity matrix between clusters instead of dissimilarities between singletons and members gives the number of observations per cluster.	

```{r}
hc1 <- hclust(dist(cent), method = "ave", members = table(mem))	
plot(hc1, hang = -1, main = "Re-start from 10 clusters")
```

## Correlation Plots

The `corrplot` package enables the graphical display of a correlation matrix, and confidence intervals, along with some tools for matrix reordering. There are seven visualization methods (parameter method) in `corrplot` package, named "circle", "square", "ellipse", "number", "shade", "color", "pie".	

Let's use [03_NC_SNP_ROI_Assoc_P_values.csv](https://umich.instructure.com/courses/38100/files/folder/data?) again to investigate the associations among SNPs using correlation plot.	

The `corrplot()` function we will be using takes correlation matrix only. So we need to get the correlation matrix of our data first via `cor()` function.	

```{r}
# install.packages("corrplot")	
library(corrplot)	
NC_Associations_Data <- read.table("https://umich.instructure.com/files/330391/download?download_frd=1", header=TRUE, row.names=1,  sep=",", dec=".")	 	
M <- cor(NC_Associations_Data)	
M[1:10, 1:10]
```

We will discover the difference among different methods under `corrplot`.

```{r}
#corrplot(M, method = "circle", title = "circle",
#         tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))	
## par specs c(bottom, left, top, right) which gives the margin size specified in inches	
#corrplot(M, method = "square", title = "square",
#         tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))	
#corrplot(M, method = "ellipse", title = "ellipse",
#         tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))	
#corrplot(M, method = "pie", title = "pie",
#         tl.cex = 0.5, tl.col = 'black', mar=c(1, 1, 1, 1))	
#corrplot(M, type = "upper", tl.pos = "td",	
#         method = "circle", tl.cex = 0.5, tl.col = 'black',	
#         order = "hclust", diag = FALSE, mar=c(1, 1, 0, 1))	
#corrplot.mixed(M, number.cex = 0.6, tl.cex = 0.6)	
```

The shades are different and darker dots represent high correlation of the two variables corresponding to the x and y axes.	

# Relationships

## Line plots using `ggplot
